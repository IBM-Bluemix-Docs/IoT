---

copyright:
  years: 2016, 2017
lastupdated: "2017-11-09"

---

{:new_window: target="\_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}

# マッピング式言語の解説
{: #mapping_expression}

マッピング式言語を使用すると、データを操作して結合したり、処理したデータに対して実行する照会の結果をフォーマット設定したりすることができます。マッピング式言語は、[JSONata ![外部リンク・アイコン](../../../icons/launch-glyph.svg "外部リンク・アイコン")](http://docs.jsonata.org/index.html){:new_window} のサブセットで、[マッピング](ga_im_definitions.html#definitions_resources)を定義する際に使用できます。JSONata は、JSON データに対して照会と変換を行うための軽量の言語です。

以下に、現在サポートされている重要な演算子と関数、およびその使用法の例をいくつか示します。 

## サポートされる JSONata 演算子
{: #operators}

以下に、サポートされる JSONata 演算子のサブセットを示します。 

演算子のタイプ                   | サポートされる演算子     | 注

------------- | ------------- | -------------
演算 | *+* - / * % | % 演算子は、剰余を返します。
比較 | < <= > >= != = | 等価演算子は = で、これは JSONata の場合と同じです。
ブール値 | *in*、*and* | ブール値の定数は、*true* または *false* です。
条件三項 | ? | ? 演算子は、テスト条件の結果に基づいて、2 つの代替式の 1 つを評価します。この演算子の形式は、*expression* ? *value_if_true* : *value_if_false* です
ストリング| & | & 演算子は、オペランドのストリング値を結合して、単一の結果のストリングにします。
シーケンス生成プログラム | .. | LHS の数値で始まり RHS の数値で終わる、増加する整数の配列を作成します (例: [1..4] -> [1,2,3,4])。オペランドの評価結果は整数でなければなりません。シーケンス生成プログラムは、配列コンストラクター [] 内でのみ使用できます。
その他 | . | ドット演算子は、リテラル・キーでのオブジェクト・アクセスに使用されます (例: $event.object.hh. * e:*)。
左側の式は、特定のプロパティー (イベント ($event) または状態 ($state) またはメタデータ ($instance) のいずれか) に制限されます。

**注:** 
- 括弧 ( ) は、式のグループ化と演算子優先順位の変更に使用します
- 単一引用符は、スペースを含んだプロパティー名を囲む場合に使用します (例: $event.object.'a b') 

## マッピング式言語の拡張

$event、$state、$instance の各変数の導入により、マッピング式言語が拡張され、データ管理フィーチャーで使用できるようになりました。JSON は、式が評価される前にこれらの変数にバインドされます。以下の表に、式で使用するために定義されたこれらの変数の概要を示します。

変数| JSON の入力例     | 式としての例    | 使用目的
------------- | ------------- | -------------
$event | *{"t": 34.5}*  | $event.t | 式で使用するインバウンド・イベントのプロパティーを選択します。
$state | *{"temperature": 34.5,"humidity": 78 }*  | $state.temperature | 式で使用するデバイスの状態に関するプロパティーを選択します。
$instance | *{"deviceId": "TemperatureSensor1","typeId": "EnvSensor1","metadata": {"temp_adjustment": 50}}*  | $instance.metadata.temp_adjustment | 式で使用するデバイス属性またはデバイス・タイプ属性を選択します。

これらの変数の使用法を結合する式を定義することもできます。次の例では、デバイス・メタデータに *temp_adjustment* プロパティーが定義され、これがイベント読み取り値の調整に使用されます。このプロパティーは、1 つのマッピングに定義されていますが、多数のデバイスに適用できます。 

```
"propertyMappings" : {
            "tevt" : {
               "temperature" : "$event.t + $instance.metadata.temp_adjustment"
        }
     },
     
```

## サポートされる JSONata 関数
{: #functions}
以下に、サポートされる JSONata 関数のサブセットを示します。 

関数のタイプ                   |関数                   | 説明 | 例
------------- | ------------- | ------------- 
ストリング| $substring(string, start_index[, length]) | ストリングのサブストリング (例: *$substring("Hello World", 3, 5) => "lo Wo"*)。
ストリング| $string(arg) | 引数をストリング値にキャストします (例: *$string(2) => "2"*)。
数値 | $number(arg) | 可能な場合、引数を数値にキャストします (例: *$number(2) => 2*)。
数値 | $sum(array) | 数値配列の演算の合計を返します (例: *([1,2,3]) = 6*)。
数値 | $average(array) | 数値配列の平均値を返します (例: *([1,2,3]) = 2.0*)。
ブール値 | $exists(expression) | 式内にプロパティーが存在する場合は *true*、そうでない場合は *false* を返します。
配列 | $count(array) | 配列パラメーター内の項目の数を返します (例: *([1,2,3,4]) = 4*)。配列パラメーターが配列ではなく、別の JSON タイプの値である場合、このパラメーターはその値を含んだシングルトン配列として処理され、この関数は *1* を返します。
配列 | $append(array1, array2) | *array1* 内の値と、その後に *array2* 内の値を含んだ配列を返します (例: *([1,2], [3,4]) = [1,2,3,4]*)。いずれのパラメーターも配列でない場合は、その値を含んだシングルトン配列として処理されます (例: *$append("Hello", "World") => ["Hello", "World"]*)。

## 配列
JSON 配列を使用して、値の集合を指定の順序で配置します。配列によって、配列内の各値が添字または位置に関連付けられます。配列内の個々の値を扱う場合は、配列のフィールド名の後に大括弧を使用して添字を指定する必要があります。大括弧内に数値が含まれている場合、または数値に評価される式が含まれている場合、その数値は選択する値の添字を表します。添字として数値の配列を使用することもできます (例: *["a","b","c"][[1,2]] -> ["b", "c"]*)。配列 *[1,2]* は、配列 *["a","b","c"]* から選択する値を識別する添字として使用されます。 

添字はゼロ・オフセットであるため、配列 *arr* 内の最初の値は *arr[0]* です (例: *[1,2,3][0] -> 1*)。この数値が整数でない場合、端数が切り捨てられて整数になります (例: *[1,2,3][0.9] -> [1]*)。

配列の末尾からカウントする場合は、負の添字を使用します (例: *[1,2,3][-1] -> 3*)。 

指定された添字が配列のサイズを超える場合は、何も選択されません。

## 出力の構成
配列コンストラクターまたはオブジェクト・コンストラクターを使用すると、出力に処理済みのデータを表示する方法を指定できます。

### サポートされる配列コンストラクター
配列を構成するには、リテラルまたは式のコンマ区切りリストを大括弧のペア ([]) で囲みます。配列コンストラクター内で複数の式を区切る場合は、コンマを使用します (例: *[1, 3-1] = [1,2]*)。

### サポートされるオブジェクト・コンストラクター
{: #constructors}
出力で JSON オブジェクトを構成するには、コンマ区切りのキー値のペアを入れた中括弧のペア {} を使用します。各キーと値はコロンで区切ります (例: *{key1 : value1, key2:value2}* または *{"hello" : "world"}*)。
オブジェクト・キーはストリングでなければなりません。  


## 例: 配列を使用した温度データの処理と報告
以下のセクションは、[データ管理の概説](ga_im_example.html)に記載された例に基づくものです。ここでは、温度読み取り値を示すスライディング・ウィンドウを配列を使用して保守し、そのウィンドウ内に示された読み取り値の現在の合計や平均を計算する方法を示しています。 

スライディング・ウィンドウには、データが到着順に保管されます。スライディング・ウィンドウは、これまでに挿入されたデータをすべて保持するのではなく、段階的にデータを削除するように構成できます。スライディング・ウィンドウがいっぱいになった後にさらに挿入すると、そのウィンドウ内の最も古いデータ項目が削除されます。

以下に、カウント・ベースの削除ポリシー (サイズは 5) によって構成されたスライディング・ウィンドウの例を示します。
```
() -> (1) -> (2, 1) -> (3, 2, 1) -> (4, 3, 2, 1) -> (5, 4, 3, 2, 1) -> (6, 5, 4, 3, 2) -> (7, 6, 5, 4, 3) -> ...
```

以下の例は、*tempReadings* という配列を追加することによって論理インターフェース・スキーマ・ファイル構成を変更する方法を示しています。これは[ステップバイステップ・ガイド](ga_im_index_scenario.html#step4)のステップ 7 で示されているものです。この配列は、最後の 5 つのイベントについて、デバイスから送信された最後の 5 つの値を示すウィンドウを保守するために使用します。*tempReadings* に値が保管されていない場合、配列は [0] に設定され、次に受け取った読み取り値が配列の末尾に追加されます。この配列は 5 つの読み取り値を受け取るまで増えていきます。5 つの読み取り値を受け取った後、新たに読み取り値を受け取ると、最も古い読み取り値がウィンドウから削除されます。 

**重要な注:** *tempReadings* を "required" に設定し、デフォルトで配列として設定する必要があります。 

```
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "definitions": {},
  "properties": {
      "temperature" : {
           "description" : "latest temperature reading in degrees Celsius",
          "type" : "number",
          "minimum" : -273.15,
          "default" : 0.0
      },
      "tempAverage": {
          "type": "number"
      },
      "tempReadings": {
          "default": [],
          "items": {
              "type": "number"
      },
         "type": "array"
      },
      "tempSum": {
          "type": "number"
      }
  },
   "required" : [
       "tempReadings"
  ],
  "type": "object"
}
```
以下のセクションでは、現在のスライディング・ウィンドウに含まれている読み取り値に基づいて温度読み取り値の平均とすべての温度の読み取り値の合計を計算するための、マッピング・リソースを構成する方法の例を示します。


```
[
   {
       "created": "2017-10-13T09:21:36Z",
       "createdBy": "admin",
       "logicalInterfaceId": "5846ec826522050001db0e12",
       "notificationStrategy": "on-state-change",
       "propertyMappings": {
           "tevt": {
               "tempAverage": "$average($count($state.tempReadings)<5?$append($state.tempReadings, $event.t):$append($state.tempReadings[[1..4]], $event.t))",
               "tempReadings": "$count($state.tempReadings)<5?$append($state.tempReadings, $event.t):$append($state.tempReadings[[1..4]], $event.t)",
               "tempSum": "$sum($count($state.tempReadings)<5?$append($state.tempReadings, $event.t):$append($state.tempReadings[[1..4]], $event.t))"
           }
       },
       "updated": "2017-10-13T10:05:40Z",
       "updatedBy": "a-8x7nmj-9iqt56kfil",
       "version": "active"
   }
]
```
**注:** *$state.tempReadings* 配列は、$average 関数と $sum 関数で使用される前に再計算されます。*tempAverage* 式または *tempSum* 式を評価する際、マッピング式の順序は制御できないため、配列に現行値を含めるために配列の再計算が必要です。

以下に、5 つの温度読み取り値が含まれるスライディング・ウィンドウに基づく平均温度と合計温度の例を示します。
```
{
    "state": {
        "tempAverage": 18557.6,
        "tempReadings": [
            17591,
            10262,
            25621,
            16676,
            22638
        ],
        "tempSum": 92788
    },
    "timestamp": "2017-10-13T11:07:20Z",
    "updated": "2017-10-13T11:05:40Z"
}
```

